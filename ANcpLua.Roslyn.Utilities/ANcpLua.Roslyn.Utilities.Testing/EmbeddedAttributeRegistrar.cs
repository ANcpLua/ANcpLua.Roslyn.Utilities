using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace ANcpLua.Roslyn.Utilities.Testing;

/// <summary>
///     Registers an embedded <c>Microsoft.CodeAnalysis.EmbeddedAttribute</c> if missing from references.
/// </summary>
/// <remarks>
///     <para>
///         This class provides a utility for generators that need the <c>EmbeddedAttribute</c>
///         to be present in the compilation. The attribute is used by some Roslyn features
///         (particularly with ref structs and spans) and may not be available in all target frameworks.
///     </para>
///     <para>
///         The source is added through
///         <see
///             cref="IncrementalGeneratorInitializationContext.RegisterSourceOutput{TSource}(IncrementalValueProvider{TSource},System.Action{SourceProductionContext,TSource})" />
///         and is guarded by a presence check on the current <see cref="Compilation" />.
///     </para>
///     <para>
///         <b>Note:</b> Only include this in your generator if you specifically need the attribute
///         at compile time. Most generators don't need this.
///     </para>
/// </remarks>
/// <example>
///     Usage in a generator:
///     <code>
/// public class MyGenerator : IIncrementalGenerator
/// {
///     public void Initialize(IncrementalGeneratorInitializationContext context)
///     {
///         // Only if you need EmbeddedAttribute in the target compilation
///         EmbeddedAttributeRegistrar.Register(context);
///
///         // ... rest of generator setup
///     }
/// }
/// </code>
/// </example>
internal static class EmbeddedAttributeRegistrar
{
    /// <summary>
    ///     Registers the embedded attribute source when not present in the compilation.
    /// </summary>
    /// <param name="context">The generator initialization context.</param>
    /// <remarks>
    ///     <para>
    ///         This method checks if <c>Microsoft.CodeAnalysis.EmbeddedAttribute</c> already exists
    ///         in the compilation's referenced types. If not, it adds a source file that defines it.
    ///     </para>
    ///     <para>
    ///         The attribute is defined as internal and sealed, matching the expected signature
    ///         for embedded attributes.
    ///     </para>
    /// </remarks>
    public static void Register(IncrementalGeneratorInitializationContext context)
    {
        // Use the compilation provider so we can check whether the type already exists in references.
        context.RegisterSourceOutput(context.CompilationProvider, (spc, compilation) =>
        {
            if (compilation.GetTypeByMetadataName("Microsoft.CodeAnalysis.EmbeddedAttribute") is null)
            {
                const string src = """
                                   // <auto-generated/>
                                   #nullable enable
                                   namespace Microsoft.CodeAnalysis
                                   {
                                       [System.Runtime.CompilerServices.CompilerGenerated]
                                       [System.AttributeUsage(System.AttributeTargets.All, Inherited = false, AllowMultiple = false)]
                                       internal sealed class EmbeddedAttribute : System.Attribute
                                       {
                                           public EmbeddedAttribute() { }
                                       }
                                   }
                                   """;

                spc.AddSource("Microsoft.CodeAnalysis.EmbeddedAttribute.g.cs", SourceText.From(src, Encoding.UTF8));
            }
        });
    }
}