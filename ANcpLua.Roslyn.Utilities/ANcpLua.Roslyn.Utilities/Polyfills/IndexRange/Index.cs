// <auto-generated />
#nullable enable

#if !NETCOREAPP3_0_OR_GREATER && !NETSTANDARD2_1_OR_GREATER

namespace System;

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

/// <summary>
///     Backport of <c>Index</c> for .NET Standard 2.0 and .NET Framework.
/// </summary>
[ExcludeFromCodeCoverage]
internal readonly struct Index : IEquatable<Index>
{
    private readonly int _value;

    /// <summary>
    ///     Initializes a new instance of the <c>Index</c> struct.
    /// </summary>
    /// <param name="value">The index value. Must be non-negative.</param>
    /// <param name="fromEnd">If <c>true</c>, the index counts from the end of the collection.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Index(int value, bool fromEnd = false)
    {
        if (value < 0) throw new ArgumentOutOfRangeException(nameof(value), "Non-negative number required.");

        _value = fromEnd ? ~value : value;
    }

    private Index(int value) => _value = value;

    /// <summary>Gets an <c>Index</c> pointing to the first element (index 0).</summary>
    public static Index Start => new(0);

    /// <summary>Gets an <c>Index</c> pointing to the position after the last element (<c>^0</c>).</summary>
    public static Index End => new(~0);

    /// <summary>Creates an <c>Index</c> from the start of a collection.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Index FromStart(int value)
    {
        if (value < 0) throw new ArgumentOutOfRangeException(nameof(value), "Non-negative number required.");
        return new Index(value);
    }

    /// <summary>Creates an <c>Index</c> from the end of a collection.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Index FromEnd(int value)
    {
        if (value < 0) throw new ArgumentOutOfRangeException(nameof(value), "Non-negative number required.");
        return new Index(~value);
    }

    /// <summary>Gets the index value.</summary>
    public int Value => _value < 0 ? ~_value : _value;

    /// <summary>Gets a value indicating whether this index counts from the end of the collection.</summary>
    public bool IsFromEnd => _value < 0;

    /// <summary>Calculates the actual offset from the start of a collection of the specified length.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int GetOffset(int length)
    {
        var offset = _value;
        if (IsFromEnd) offset += length + 1;
        return offset;
    }

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is Index other && _value == other._value;

    /// <inheritdoc />
    public bool Equals(Index other) => _value == other._value;

    /// <inheritdoc />
    public override int GetHashCode() => _value;

    /// <summary>Implicitly converts an <see cref="int" /> to an <c>Index</c> from the start.</summary>
    public static implicit operator Index(int value) => FromStart(value);

    /// <summary>Returns a string representation of this index.</summary>
    public override string ToString() => IsFromEnd ? "^" + Value : ((uint)Value).ToString();
}
#endif
