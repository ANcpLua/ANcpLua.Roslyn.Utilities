namespace ANcpLua.Roslyn.Utilities;

/// <summary>
///     Provides helper methods for generating common code patterns in source generators.
///     <para>
///         This static class contains string constants and factory methods for generating
///         attributes, pragmas, and file headers commonly used in source-generated code.
///     </para>
/// </summary>
/// <remarks>
///     <list type="bullet">
///         <item>
///             <description>
///                 All generated strings use fully-qualified type names with <c>global::</c> prefix to avoid
///                 namespace conflicts.
///             </description>
///         </item>
///         <item>
///             <description>Methods are designed for use in Roslyn incremental source generators.</description>
///         </item>
///         <item>
///             <description>String interpolation is used for efficient code generation.</description>
///         </item>
///     </list>
/// </remarks>
/// <seealso cref="IndentedStringBuilder" />
#if ANCPLUA_ROSLYN_PUBLIC
public
#else
internal
#endif
    static class GeneratedCodeHelpers
{
    /// <summary>
    ///     Gets the <c>#nullable enable</c> preprocessor directive.
    /// </summary>
    /// <returns>The string <c>"#nullable enable"</c>.</returns>
    public static string NullableEnable => "#nullable enable";

    /// <summary>
    ///     Gets the <c>#nullable disable</c> preprocessor directive.
    /// </summary>
    /// <returns>The string <c>"#nullable disable"</c>.</returns>
    public static string NullableDisable => "#nullable disable";

    /// <summary>
    ///     Gets the <c>#nullable restore</c> preprocessor directive.
    /// </summary>
    /// <returns>The string <c>"#nullable restore"</c>.</returns>
    public static string NullableRestore => "#nullable restore";

    /// <summary>
    ///     Generates a <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute" /> declaration.
    /// </summary>
    /// <param name="toolName">The name of the tool that generated the code.</param>
    /// <param name="version">The optional version of the tool. If <c>null</c>, the version parameter is set to <c>null</c>.</param>
    /// <returns>
    ///     A string containing the fully-qualified <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute" /> with the
    ///     specified tool name and version.
    /// </returns>
    public static string GeneratedCodeAttribute(string toolName, string? version = null) =>
        version is null
            ? $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{toolName}\", null)]"
            : $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{toolName}\", \"{version}\")]";

    /// <summary>
    ///     Gets the <see cref="System.ComponentModel.EditorBrowsableAttribute" /> with
    ///     <see cref="System.ComponentModel.EditorBrowsableState.Never" />.
    ///     <para>
    ///         This attribute hides the member from IntelliSense in code editors.
    ///     </para>
    /// </summary>
    /// <returns>A string containing the fully-qualified attribute declaration.</returns>
    public static string EditorBrowsableNever =>
        "[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]";

    /// <summary>
    ///     Gets the <see cref="System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute" /> declaration.
    ///     <para>
    ///         This attribute excludes the decorated member from code coverage analysis.
    ///     </para>
    /// </summary>
    /// <returns>A string containing the fully-qualified attribute declaration.</returns>
    public static string ExcludeFromCodeCoverage =>
        "[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]";

    /// <summary>
    ///     Gets the <see cref="System.Diagnostics.DebuggerNonUserCodeAttribute" /> declaration.
    ///     <para>
    ///         This attribute indicates that the decorated code is not user code, causing the debugger to step through it.
    ///     </para>
    /// </summary>
    /// <returns>A string containing the fully-qualified attribute declaration.</returns>
    public static string DebuggerNonUserCode =>
        "[global::System.Diagnostics.DebuggerNonUserCode]";

    /// <summary>
    ///     Gets the <see cref="System.Runtime.CompilerServices.CompilerGeneratedAttribute" /> declaration.
    ///     <para>
    ///         This attribute indicates that the decorated element is generated by the compiler.
    ///     </para>
    /// </summary>
    /// <returns>A string containing the fully-qualified attribute declaration.</returns>
    public static string CompilerGenerated =>
        "[global::System.Runtime.CompilerServices.CompilerGenerated]";

    /// <summary>
    ///     Generates a standard auto-generated file header comment.
    /// </summary>
    /// <param name="toolName">The name of the tool that generated the file.</param>
    /// <returns>
    ///     A multi-line string containing the auto-generated header with an XML comment marker
    ///     and instructions not to modify the file directly.
    /// </returns>
    /// <seealso cref="AutoGeneratedHeaderWithTimestamp" />
    public static string AutoGeneratedHeader(string toolName) =>
        $"""
         // <auto-generated/>
         // This file was auto-generated by {toolName}.
         // Do not modify this file directly.

         """;

    /// <summary>
    ///     Generates an auto-generated file header comment with a timestamp.
    /// </summary>
    /// <param name="toolName">The name of the tool that generated the file.</param>
    /// <param name="timestamp">The <see cref="DateTimeOffset" /> when the file was generated, formatted in ISO 8601 format.</param>
    /// <returns>
    ///     A multi-line string containing the auto-generated header with the tool name, timestamp,
    ///     and instructions not to modify the file directly.
    /// </returns>
    /// <seealso cref="AutoGeneratedHeader" />
    public static string AutoGeneratedHeaderWithTimestamp(string toolName, DateTimeOffset timestamp) =>
        $"""
         // <auto-generated/>
         // This file was auto-generated by {toolName} at {timestamp:O}.
         // Do not modify this file directly.

         """;

    /// <summary>
    ///     Generates a <c>#pragma warning disable</c> directive for the specified warning IDs.
    /// </summary>
    /// <param name="warningIds">The warning IDs to suppress (e.g., <c>"CS1591"</c>, <c>"CS0618"</c>).</param>
    /// <returns>
    ///     A string containing the pragma directive, or <see cref="string.Empty" /> if <paramref name="warningIds" /> is
    ///     empty.
    /// </returns>
    /// <seealso cref="RestoreWarnings" />
    public static string SuppressWarnings(params string[] warningIds)
    {
        if (warningIds.Length is 0)
            return string.Empty;
        return $"#pragma warning disable {string.Join(", ", warningIds)}";
    }

    /// <summary>
    ///     Generates a <c>#pragma warning restore</c> directive for the specified warning IDs.
    /// </summary>
    /// <param name="warningIds">The warning IDs to restore (e.g., <c>"CS1591"</c>, <c>"CS0618"</c>).</param>
    /// <returns>
    ///     A string containing the pragma directive, or <see cref="string.Empty" /> if <paramref name="warningIds" /> is
    ///     empty.
    /// </returns>
    /// <seealso cref="SuppressWarnings" />
    public static string RestoreWarnings(params string[] warningIds)
    {
        if (warningIds.Length is 0)
            return string.Empty;
        return $"#pragma warning restore {string.Join(", ", warningIds)}";
    }
}

/// <summary>
///     A <see cref="StringBuilder" />-based builder that automatically manages indentation for code generation.
///     <para>
///         This class provides fluent methods for building indented source code with support for
///         common code structures like namespaces, classes, methods, and control flow statements.
///     </para>
/// </summary>
/// <remarks>
///     <list type="bullet">
///         <item>
///             <description>All <c>Append</c> and <c>AppendLine</c> methods automatically prepend the current indentation.</description>
///         </item>
///         <item>
///             <description>Use <see cref="BeginBlock" /> with a <c>using</c> statement for automatic block closure.</description>
///         </item>
///         <item>
///             <description>The builder is reusable via the <see cref="Clear" /> method.</description>
///         </item>
///     </list>
/// </remarks>
/// <seealso cref="IndentScope" />
/// <seealso cref="GeneratedCodeHelpers" />
#if ANCPLUA_ROSLYN_PUBLIC
public
#else
internal
#endif
    sealed class IndentedStringBuilder
{
    private readonly StringBuilder _sb;
    private readonly string _indentString;
    private int _indentLevel;
    private bool _needsIndent;

    /// <summary>
    ///     Initializes a new instance of the <see cref="IndentedStringBuilder" /> class.
    /// </summary>
    /// <param name="initialCapacity">The initial capacity of the underlying <see cref="StringBuilder" />. Defaults to 256.</param>
    /// <param name="indentString">The string to use for each level of indentation. Defaults to four spaces.</param>
    public IndentedStringBuilder(int initialCapacity = 256, string indentString = "    ")
    {
        _sb = new StringBuilder(initialCapacity);
        _indentString = indentString;
        _needsIndent = true;
    }

    /// <summary>
    ///     Gets the current length of the generated content.
    /// </summary>
    public int Length => _sb.Length;

    /// <summary>
    ///     Appends the specified text to the builder with the current indentation.
    /// </summary>
    /// <param name="text">The text to append.</param>
    /// <returns>This instance for method chaining.</returns>
    public IndentedStringBuilder Append(string text)
    {
        WriteIndentIfNeeded();
        _sb.Append(text);
        return this;
    }

    /// <summary>
    ///     Appends the specified character to the builder with the current indentation.
    /// </summary>
    /// <param name="c">The character to append.</param>
    /// <returns>This instance for method chaining.</returns>
    public IndentedStringBuilder Append(char c)
    {
        WriteIndentIfNeeded();
        _sb.Append(c);
        return this;
    }

    /// <summary>
    ///     Appends a new line to the builder.
    /// </summary>
    /// <returns>This instance for method chaining.</returns>
    public IndentedStringBuilder AppendLine()
    {
        _sb.AppendLine();
        _needsIndent = true;
        return this;
    }

    /// <summary>
    ///     Appends the specified text followed by a new line, with the current indentation.
    /// </summary>
    /// <param name="text">The text to append before the new line.</param>
    /// <returns>This instance for method chaining.</returns>
    public IndentedStringBuilder AppendLine(string text)
    {
        WriteIndentIfNeeded();
        _sb.AppendLine(text);
        _needsIndent = true;
        return this;
    }

    /// <summary>
    ///     Appends the specified text followed by a new line without applying indentation.
    ///     <para>
    ///         Use this method for preprocessor directives or other content that should not be indented.
    ///     </para>
    /// </summary>
    /// <param name="text">The text to append before the new line.</param>
    /// <returns>This instance for method chaining.</returns>
    public IndentedStringBuilder AppendLineNoIndent(string text)
    {
        _sb.AppendLine(text);
        _needsIndent = true;
        return this;
    }

    private void Indent() => _indentLevel++;

    private void Outdent()
    {
        if (_indentLevel > 0)
            _indentLevel--;
    }

    /// <summary>
    ///     Begins a new code block, optionally writing an opening delimiter, and increases indentation.
    /// </summary>
    /// <param name="opener">The opening delimiter to write (e.g., <c>"{"</c>). If <c>null</c>, no opener is written.</param>
    /// <returns>
    ///     An <see cref="IndentScope" /> that, when disposed, calls <see cref="EndBlock" /> to close the block.
    /// </returns>
    /// <seealso cref="EndBlock" />
    public IndentScope BeginBlock(string? opener = "{")
    {
        if (opener is not null)
            AppendLine(opener);
        Indent();
        return new IndentScope(this);
    }

    /// <summary>
    ///     Begins a namespace declaration and opens a block.
    /// </summary>
    /// <param name="namespaceName">The fully-qualified namespace name.</param>
    /// <returns>
    ///     An <see cref="IndentScope" /> that, when disposed, closes the namespace block.
    /// </returns>
    public IndentScope BeginNamespace(string namespaceName)
    {
        AppendLine($"namespace {namespaceName}");
        return BeginBlock();
    }

    /// <summary>
    ///     Begins a class declaration and opens a block.
    /// </summary>
    /// <param name="modifiers">The access and other modifiers (e.g., <c>"public partial"</c>).</param>
    /// <param name="className">The name of the class.</param>
    /// <param name="baseType">The optional base type or interface list. If <c>null</c>, no inheritance clause is added.</param>
    /// <returns>
    ///     An <see cref="IndentScope" /> that, when disposed, closes the class block.
    /// </returns>
    public IndentScope BeginClass(string modifiers, string className, string? baseType = null)
    {
        var declaration = baseType is null
            ? $"{modifiers} class {className}"
            : $"{modifiers} class {className} : {baseType}";
        AppendLine(declaration);
        return BeginBlock();
    }

    /// <summary>
    ///     Begins a method declaration and opens a block.
    /// </summary>
    /// <param name="modifiers">The access and other modifiers (e.g., <c>"public async"</c>).</param>
    /// <param name="returnType">The return type of the method (e.g., <c>"void"</c>, <c>"Task"</c>).</param>
    /// <param name="methodName">The name of the method.</param>
    /// <param name="parameters">The parameter list without parentheses. Defaults to empty string for parameterless methods.</param>
    /// <returns>
    ///     An <see cref="IndentScope" /> that, when disposed, closes the method block.
    /// </returns>
    public IndentScope BeginMethod(string modifiers, string returnType, string methodName, string parameters = "")
    {
        AppendLine($"{modifiers} {returnType} {methodName}({parameters})");
        return BeginBlock();
    }

    /// <summary>
    ///     Begins an <c>if</c> statement and opens a block.
    /// </summary>
    /// <param name="condition">The condition expression without parentheses.</param>
    /// <returns>
    ///     An <see cref="IndentScope" /> that, when disposed, closes the <c>if</c> block.
    /// </returns>
    /// <seealso cref="BeginElse" />
    public IndentScope BeginIf(string condition)
    {
        AppendLine($"if ({condition})");
        return BeginBlock();
    }

    /// <summary>
    ///     Begins an <c>else</c> clause and opens a block.
    /// </summary>
    /// <returns>
    ///     An <see cref="IndentScope" /> that, when disposed, closes the <c>else</c> block.
    /// </returns>
    /// <seealso cref="BeginIf" />
    public IndentScope BeginElse()
    {
        AppendLine("else");
        return BeginBlock();
    }

    /// <summary>
    ///     Begins a <c>foreach</c> loop and opens a block.
    /// </summary>
    /// <param name="variableType">The type of the loop variable (e.g., <c>"var"</c>, <c>"int"</c>).</param>
    /// <param name="variableName">The name of the loop variable.</param>
    /// <param name="collection">The collection expression to iterate over.</param>
    /// <returns>
    ///     An <see cref="IndentScope" /> that, when disposed, closes the <c>foreach</c> block.
    /// </returns>
    public IndentScope BeginForEach(string variableType, string variableName, string collection)
    {
        AppendLine($"foreach ({variableType} {variableName} in {collection})");
        return BeginBlock();
    }

    /// <summary>
    ///     Ends a code block by decreasing indentation and optionally writing a closing delimiter.
    /// </summary>
    /// <param name="closer">The closing delimiter to write (e.g., <c>"}"</c>). If <c>null</c>, no closer is written.</param>
    /// <seealso cref="BeginBlock" />
    public void EndBlock(string? closer = "}")
    {
        Outdent();
        if (closer is not null)
            AppendLine(closer);
    }

    /// <summary>
    ///     Returns the generated content as a string.
    /// </summary>
    /// <returns>The complete generated source code.</returns>
    public override string ToString() => _sb.ToString();

    /// <summary>
    ///     Clears all content and resets the indentation level to zero.
    /// </summary>
    public void Clear()
    {
        _sb.Clear();
        _indentLevel = 0;
        _needsIndent = true;
    }

    private void WriteIndentIfNeeded()
    {
        if (!_needsIndent)
            return;

        for (var i = 0; i < _indentLevel; i++)
            _sb.Append(_indentString);

        _needsIndent = false;
    }
}

/// <summary>
///     A disposable struct that automatically closes a code block when disposed.
///     <para>
///         This struct is designed to be used with <c>using</c> statements to ensure
///         proper block closure in <see cref="IndentedStringBuilder" />.
///     </para>
/// </summary>
/// <remarks>
///     <list type="bullet">
///         <item>
///             <description>Created by <see cref="IndentedStringBuilder.BeginBlock" /> and related methods.</description>
///         </item>
///         <item>
///             <description>Calls <see cref="IndentedStringBuilder.EndBlock" /> when disposed.</description>
///         </item>
///         <item>
///             <description>Implemented as a <c>readonly struct</c> for zero-allocation usage.</description>
///         </item>
///     </list>
/// </remarks>
/// <seealso cref="IndentedStringBuilder" />
#if ANCPLUA_ROSLYN_PUBLIC
public
#else
internal
#endif
    readonly struct IndentScope : IDisposable
{
    private readonly IndentedStringBuilder _builder;

    /// <summary>
    ///     Initializes a new instance of the <see cref="IndentScope" /> struct.
    /// </summary>
    /// <param name="builder">The <see cref="IndentedStringBuilder" /> that owns this scope.</param>
    public IndentScope(IndentedStringBuilder builder) => _builder = builder;

    /// <summary>
    ///     Closes the code block by calling <see cref="IndentedStringBuilder.EndBlock" /> on the owning builder.
    /// </summary>
    public void Dispose()
    {
        _builder.EndBlock();
    }
}
